source('C:/Users/ffrib/OneDrive - ufba.br/pgcomp/ESE/analise quantitativa/Falhas na Build/Questao 03.r', encoding = 'UTF-8', echo=TRUE)
knitr::opts_chunk$set(echo = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(knitr, warn.conflicts = FALSE)
library(pander, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(gmodels, warn.conflicts = FALSE)
library(ggplot2, warn.conflicts = FALSE)
library(png, warn.conflicts = FALSE)
library(lubridate, warn.conflicts = FALSE)
library(bursts, warn.conflicts = FALSE)
library(Hmisc, warn.conflicts = FALSE)
library(effsize, warn.conflicts = FALSE)
library(DescTools, warn.conflicts = FALSE)
library(png)
knitr::opts_chunk$set(echo = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(knitr, warn.conflicts = FALSE)
library(pander, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(gmodels, warn.conflicts = FALSE)
library(ggplot2, warn.conflicts = FALSE)
library(png, warn.conflicts = FALSE)
library(lubridate, warn.conflicts = FALSE)
library(bursts, warn.conflicts = FALSE)
library(Hmisc, warn.conflicts = FALSE)
library(effsize, warn.conflicts = FALSE)
library(DescTools, warn.conflicts = FALSE)
#Importatando bibliotecas
library(dplyr)
library(knitr)
library(tidyr)
library(pander)
library(gmodels)
library(ggplot2)
library(png)
library(lubridate)
library(bursts)
library(DescTools)
source('C:/Users/ffrib/OneDrive - ufba.br/pgcomp/ESE/analise quantitativa/Falhas na Build/Questoes 01 e 02.R', echo=TRUE)
source('C:/Users/ffrib/OneDrive - ufba.br/pgcomp/ESE/analise quantitativa/Falhas na Build/Questao 03.r', encoding = 'UTF-8', echo=TRUE)
library(dplyr)
library(tidyr)
library(pander)
library(gmodels)
library(ggplot2)
library(dplyr)
library(tidyr)
require("igraph")
source('C:/Users/ffrib/OneDrive - ufba.br/pgcomp/ESE/analise quantitativa/Falhas na Build/Questao 03.r', encoding = 'UTF-8')
install.packages("pander")
library(dplyr)
library(tidyr)
library(pander)
library(gmodels)
library(ggplot2)
library(lubridate)
library(bursts)
library(DescTools)
install.packages("bursts")
library(dplyr)
library(tidyr)
library(pander)
library(gmodels)
library(ggplot2)
library(lubridate)
library(bursts)
library(DescTools)
travis  <- readRDS('travis-sample.rds')
commits <- readRDS('commits-sample.rds')
kLevel <- 2
build_brust <- data.frame(  )
travis <- travis %>%  mutate(status_logic = if_else(tr_status == 'passed', TRUE, FALSE) )
travis_commitsQ3 <- travis %>%
select(tr_job_id, git_all_built_commits) %>%
mutate(git_commit_id = strsplit(git_all_built_commits, "#"))  %>%
unnest(git_commit_id) %>%
select(tr_job_id, git_commit_id)
Job_commitQ3 <-travis %>%
inner_join(travis_commitsQ3, by = c("tr_job_id"))
commits <- commits %>% mutate(time = ymd_hms(date))
proj.loop  <- commits
while( nrow(proj.loop) > 0 ) {
#nome do projeto atual
proj.nome  <- proj.loop$gh_project_name[1]
str(proj.nome)
# separando o projeto atual
proj.atual <- proj.loop %>% filter( gh_project_name == proj.nome )
# retirando projeto atual do loop
proj.loop  <- proj.loop %>% filter( gh_project_name != proj.nome )
# apagando commits concomitantes
proj.atual <- proj.atual %>% group_by(time) %>%
summarise(gh_project_name =unique(gh_project_name),
git_commit_id = max(git_commit_id))
# algoritmo de kleinberg
k <- kleinberg(proj.atual$time)
#plot.bursts(k)
# separando um nivel de rajada
k <- subset(k, level == kLevel)
# ordenando os breaks
breaks = sort(c(k$start, k$end))
# criando variavel logica isBurst
# se o commit pertence a um brust <- TRUE se não <- FALSE
proj.atual <- proj.atual %>%
mutate(isBurst = cut(time, breaks=breaks, labels=FALSE)) %>%
mutate(isBurst = if_else(is.na(isBurst), F, isBurst %% 2 == 1))
# relacionadno comits e status
proj.atual <- proj.atual  %>% inner_join(Job_commitQ3, by = c("git_commit_id", "gh_project_name"))
# Agrupando por build
proj.builds <- proj.atual %>%
group_by(tr_build_id) %>%
summarise(
status_logic = unique(status_logic),
# se ao menos um dos commits é rajada, a build e considerada rajada
isBurst = any(isBurst),
burst_passed = status_logic & isBurst,
gh_project_name = unique(gh_project_name)
)
if( length(proj.builds) != 0)
{ build_brust <- rbind(build_brust, proj.builds ) }#end if
}# end while
commits <- readRDS('commits-sample.rds')
View(commits)
commits <- commits %>% mutate(time = ymd_hms(date))
travis  <- readRDS('travis-sample.rds')
View(travis)
travis  <- readRDS('travis-sample.rds')
commits <- readRDS('commits-sample.rds')
# nível das rajadas
kLevel <- 2
# dataset vazio para armazenar os resultados
build_brust <- data.frame(  )
# Status da build como vetor logico
travis <- travis %>%  mutate(status_logic = if_else(tr_status == 'passed', TRUE, FALSE) )
# Relaciona cada build job com os commits correspondentes
travis_commitsQ3 <- travis %>%
select(tr_job_id, git_all_built_commits) %>%
mutate(git_commit_id = strsplit(git_all_built_commits, "#"))  %>%
unnest(git_commit_id) %>%
select(tr_job_id, git_commit_id)
Job_commitQ3 <-travis %>%
inner_join(travis_commitsQ3, by = c("tr_job_id"))
View(commits)
